<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>3D tests</title>
		<style>
			body { 
            margin: 0; 
            color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #fff;
				margin: 0px;
         }
			canvas { width: 100%; height: 100% }
         
			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				box-sizing: border-box;
			}
		</style>
	</head>
	<body>
         <div id="info">
         <p></p>
               MOVE mouse &amp; press A: rotate, S: zoom, D: pan
            </div>
      <script src="js/libs/three.js"></script>
      <script src="js/libs/TrackballControls.js"></script>
      <script src="js/libs/Tween.js"></script>
      <script src="js/libs/ObjectControls.js"></script>
		<script>
var container;
var camera, controls, scene, renderer, INTERSECTEDMOUSEDOWN, INTERSECTEDMOUSEUP;
var raycaster, mouse = { x : 0, y : 0 };
colors = ['#81d8d0', '#fff25d', '#3197e0']
var items = [], flag, animation;
			init();
			animate();
			function init() {
            camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set(600, 10, 2200);
				controls = new THREE.TrackballControls( camera, scene );
				controls.rotateSpeed = 1.2;
				controls.zoomSpeed = 1.5;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
            controls.keys = [ 65, 83, 68 ];
            controls.target.set( 600, -150, 450 );
				controls.addEventListener( 'change', render );
				// world
            scene = new THREE.Scene();
            raycaster = new THREE.Raycaster();
				scene.background = new THREE.Color( '#54455C' );
				var geometry = new THREE.BoxGeometry( 400, 1, 300 );
				for ( var i = 0; i < 3; i ++ ) {
               for ( var j = 0; j < 3; j ++ ) {
                  for ( var k = 0; k < 3; k ++ ) {
                     var texture = new THREE.TextureLoader().load( 'textures/diag.jpg' );
                     var material = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture } );
                     var materials = [
                        // new THREE.MeshNormalMaterial(),
                        // new THREE.MeshBasicMaterial( { wireframe: true } ),
                        
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                        new THREE.MeshBasicMaterial( { map: texture } ),
                        new THREE.MeshBasicMaterial( { color: colors[j] } ),
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                     ];
                     var mesh = new THREE.Mesh( geometry, materials, transparent = true, opacity = 0.2 );
                     mesh.material.forEach(m => {
                        m.transparent = true;
                        m.opacity = 1;
                     })
                     mesh.position.x = i * 600;
                     mesh.position.y = - j * 200;
                     mesh.position.z = k * 500;
                     mesh.userData.column = i;
                     mesh.userData.layer = j;
                     mesh.userData.row = k;
                     mesh.userData.type = 'cubeElement';
                     mesh.updateMatrix();
                     mesh.matrixAutoUpdate = false;
                     scene.add( mesh );
                     items.push( mesh );
                  }
               }
				}
            var geometryC = new THREE.CylinderGeometry( 150, 150, 200, 32 );

            var geometryC = new THREE.CylinderGeometry( 150, 150, 200, 32 );
            for (var i = 0; i < 3; i++) {
               var materialC = new THREE.MeshBasicMaterial( { color: colors[i] } );
               var meshC = new THREE.Mesh( geometryC, materialC, transparent = true, opacity = 0.2 );
               meshC.position.x = 2000;
               meshC.position.y = -i*200;
               meshC.position.z = 500;
               meshC.userData.type = 'navColumnElement';
               meshC.userData.layer = i;
               meshC.updateMatrix();
               meshC.matrixAutoUpdate = false;
               scene.add( meshC );
            }

            
            var geometryT = new THREE.BoxGeometry( 400, 300, 300 );
            var materialT = [
               new THREE.MeshBasicMaterial( { color: 'green', side: THREE.DoubleSide } ),
               new THREE.MeshBasicMaterial( { color: 'red',side: THREE.DoubleSide } ),
               new THREE.MeshBasicMaterial( { color: 'white', transparent:true, opacity: 0,side: THREE.DoubleSide }),
               new THREE.MeshBasicMaterial( { color: 'white', transparent:true, opacity: 0, side: THREE.DoubleSide } ),
               new THREE.MeshBasicMaterial( { color: 'blue',side: THREE.DoubleSide } ),
                new THREE.MeshBasicMaterial( { color: 'yellow',side: THREE.DoubleSide } ),
            ];

            // renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
            renderer.domElement.addEventListener( 'dblclick', onDblClick, false );
            renderer.domElement.addEventListener("mousemove", () => flag = 1, false);
            document.addEventListener( 'mousedown', () => flag = 0, false );  
            document.body.appendChild( renderer.domElement );
            
            var meshT = new THREE.Mesh( geometryT, materialT );
            meshT.position.x = 2000;
            meshT.position.y = -200;
            meshT.position.z = 1000;
            meshT.userData.type = 'infoCube';
            meshT.userData.layer = 1;
            meshT.updateMatrix();
            meshT.matrixAutoUpdate = false;
            scene.add( meshT );
            controlsT = new THREE.ObjectControls(camera, renderer.domElement, meshT);
            controlsT.setDistance(8, 200); // set min - max distance for zoom
            controlsT.setZoomSpeed(1); // set zoom speed
				//
				window.addEventListener( 'resize', onWindowResize, false );
				//
				render();
         }

         function onDblClick() {
            console.log('a');
         }

         function onDocumentMouseUp( e ) {
            if (flag === 0) {
               mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
               mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

               raycaster.setFromCamera( mouse, camera );    

               var intersects = raycaster.intersectObjects( scene.children );

               if ( intersects.length > 0 ) {
                  if ( INTERSECTEDMOUSEUP != intersects[ 0 ].object) {
                     // console.log( intersects[ 0 ].object ); 
                     INTERSECTEDMOUSEUP = intersects[ 0 ].object;
                     if (INTERSECTEDMOUSEUP.userData.type === 'cubeElement') {
                        items.forEach(item => {
                           if(item.userData.column === INTERSECTEDMOUSEUP.userData.column && item.userData.row === INTERSECTEDMOUSEUP.userData.row) {
                              item.material.forEach(m => {
                                 m.opacity = 1;
                              })
                           } else {
                              item.material.forEach(m => {
                                 m.opacity = 0.2;
                              })
                           }
                        })
                        animateCameraOnClickElement(INTERSECTEDMOUSEUP);
                     }
                     if (INTERSECTEDMOUSEUP.userData.type === 'navColumnElement') { 
                        items.forEach(item => {
                           if(item.userData.layer === INTERSECTEDMOUSEUP.userData.layer) {
                              item.material.forEach(m => {
                                 m.opacity = 1;
                              })
                           } else {
                              item.material.forEach(m => {
                                 m.opacity = 0.2;
                              })
                           }
                        })
                        animateCameraToStartPos(INTERSECTEDMOUSEUP.userData.layer);
                     }
                  } else {
                     INTERSECTEDMOUSEUP = null;
                  }
               } else {
                  items.forEach(item => {
                        item.material.forEach(m => {
                           m.opacity = 1;
                      })
                  })
                  animateCameraToStartPos(1);
               }
            }
         }

         function animateCameraOnClickElement(INTERSECTEDMOUSEUP) {
            var fromControlsTarget = {
                        x: controls.target.x,
                        y: controls.target.y,
                        z: controls.target.z
                     };

                     var toControlsTarget = {
                        x: INTERSECTEDMOUSEUP.position.x,
                        y: INTERSECTEDMOUSEUP.position.y - 200,
                        z: INTERSECTEDMOUSEUP.position.z
                     };
                     var fromCameraPosition = {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                     };

                     var toCameraPosition = {
                        x: INTERSECTEDMOUSEUP.position.x - 300,
                        y: INTERSECTEDMOUSEUP.position.y + 200,
                        z: INTERSECTEDMOUSEUP.position.z + 500
                     };
                     controls.reset();
                     var tweenControlsTarget = new TWEEN.Tween(fromControlsTarget)
                        .to(toControlsTarget, 1000)
                        .easing(TWEEN.Easing.Linear.None)
                        .onUpdate(function () {
                           controls.target.set(this._object.x, this._object.y, this._object.z);
                        })
                        .start()

                     var tweenCameraPosition = new TWEEN.Tween(fromCameraPosition)
                        .to(toCameraPosition, 1000)
                        .easing(TWEEN.Easing.Linear.None)
                        .onUpdate(function () {
                           camera.position.set(this._object.x, this._object.y, this._object.z);
                        })
                        .start() 
         }

         function animateCameraToStartPos(k) {
            var fromControlsTarget = {
               x: controls.target.x,
               y: controls.target.y,
               z: controls.target.z
            };

            var toControlsTarget = {
               x: 600,
               y: k*-150,
               z: 450
            };
            var fromCameraPosition = {
               x: camera.position.x,
               y: camera.position.y,
               z: camera.position.z
            };

            var toCameraPosition = {
               x: 600,
               y: 400 - k*150,
               z: 2200
            };
            controls.reset();
            var tweenControlsTarget = new TWEEN.Tween(fromControlsTarget)
                  .to(toControlsTarget, 1000)
                  .easing(TWEEN.Easing.Linear.None)
                  .onUpdate(function () {
                     controls.target.set(this._object.x, this._object.y, this._object.z);
                  })
                  .start()
            var tweenCameraPosition = new TWEEN.Tween(fromCameraPosition)
               .to(toCameraPosition, 1000)
               .easing(TWEEN.Easing.Linear.None)
               .onUpdate(function () {
                  camera.position.set(this._object.x, this._object.y, this._object.z);
               })
               .start()
         }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				controls.handleResize();
				render();
         }
         
			function animate() {
            render();
            requestAnimationFrame( animate );
            TWEEN.update();
				controls.update();			
         }
         
			function render() {
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>