<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>3D tests</title>
		<style>
			body { 
            margin: 0; 
            color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #fff;
				margin: 0px;
         }
			canvas { width: 100%; height: 100% }
         
			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				box-sizing: border-box;
			}
		</style>
	</head>
	<body>
         <div id="info">
         <p></p>
               MOVE mouse &amp; press A: rotate, S: zoom, D: pan
            </div>
      <script src="js/three.js"></script>
      <script src="js/TrackballControls.js"></script>
      <script src="js/Tween.js"></script>
		<script>
var container;
var camera, controls, scene, renderer, INTERSECTEDMOUSEDOWN, INTERSECTEDMOUSEUP;
var raycaster, mouse = { x : 0, y : 0 };
var items = [], flag, animation;
			init();
			animate();
			function init() {
            camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set(600, 10, 2200);
				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 1.2;
				controls.zoomSpeed = 1.5;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
            controls.keys = [ 65, 83, 68 ];
            controls.target.set( 600, -150, 450 );
				controls.addEventListener( 'change', render );
				// world
            scene = new THREE.Scene();
            raycaster = new THREE.Raycaster();
				scene.background = new THREE.Color( '#54455C' );
				var geometry = new THREE.BoxGeometry( 400, 1, 300 );
				for ( var i = 0; i < 3; i ++ ) {
               for ( var j = 0; j < 3; j ++ ) {
                  for ( var k = 0; k < 3; k ++ ) {
                     var texture = new THREE.TextureLoader().load( 'textures/diag.jpg' );
                     var material = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture } );
                     var materials = [
                        // new THREE.MeshNormalMaterial(),
                        // new THREE.MeshBasicMaterial( { wireframe: true } ),
                        
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                        new THREE.MeshBasicMaterial( { map: texture } ),
                        new THREE.MeshBasicMaterial( { color: 'white' } ),
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                        new THREE.MeshBasicMaterial( { color: 'black' } ),
                     ];
                     var mesh = new THREE.Mesh( geometry, materials, transparent = true, opacity = 0.2 );
                     mesh.material.forEach(m => {
                        m.transparent = true;
                        m.opacity = 1;
                     })
                     mesh.position.x = i * 600;
                     mesh.position.y = - j * 200;
                     mesh.position.z = k * 500;
                     mesh.userData.column = i;
                     mesh.userData.layer = j;
                     mesh.userData.row = k;
                     mesh.updateMatrix();
                     mesh.matrixAutoUpdate = false;
                     scene.add( mesh );
                     items.push( mesh );
                  }
               }
				}
            
            // renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
            renderer.domElement.addEventListener("mousemove", () => flag = 1, false);
            document.addEventListener( 'mousedown', () => flag = 0, false );  
				document.body.appendChild( renderer.domElement );
				//
				window.addEventListener( 'resize', onWindowResize, false );
				//
				render();
         }

         function onDocumentMouseUp( e ) {
            if (flag === 0) {
               mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
               mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

               raycaster.setFromCamera( mouse, camera );    

               var intersects = raycaster.intersectObjects( scene.children );

               if ( intersects.length > 0 ) {
                  if ( INTERSECTEDMOUSEUP != intersects[ 0 ].object) {
                     console.log( intersects[ 0 ].object ); 
                     INTERSECTEDMOUSEUP = intersects[ 0 ].object;
                     items.forEach(item => {
                        if(item.userData.column === INTERSECTEDMOUSEUP.userData.column && item.userData.row === INTERSECTEDMOUSEUP.userData.row) {
                           item.material.forEach(m => {
                              m.opacity = 1;
                           })
                        } else {
                           item.material.forEach(m => {
                              m.opacity = 0.2;
                           })
                        }
                     })

                     var fromControlsTarget = {
                        x: controls.target.x,
                        y: controls.target.y,
                        z: controls.target.z
                     };

                     var toControlsTarget = {
                        x: INTERSECTEDMOUSEUP.position.x,
                        y: INTERSECTEDMOUSEUP.position.y - 200,
                        z: INTERSECTEDMOUSEUP.position.z
                     };
                     var fromCameraPosition = {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                     };

                     var toCameraPosition = {
                        x: INTERSECTEDMOUSEUP.position.x - 300,
                        y: INTERSECTEDMOUSEUP.position.y + 200,
                        z: INTERSECTEDMOUSEUP.position.z + 500
                     };
                     controls.reset();
                     var tweenControlsTarget = new TWEEN.Tween(fromControlsTarget)
                        .to(toControlsTarget, 1000)
                        .easing(TWEEN.Easing.Linear.None)
                        .onUpdate(function () {
                           controls.target.set(this._object.x, this._object.y, this._object.z);
                        })
                        .start()

                     var tweenCameraPosition = new TWEEN.Tween(fromCameraPosition)
                        .to(toCameraPosition, 1000)
                        .easing(TWEEN.Easing.Linear.None)
                        .onUpdate(function () {
                           camera.position.set(this._object.x, this._object.y, this._object.z);
                        })
                        .start() 
                  } else {
                     INTERSECTEDMOUSEUP = null;
                  }
               } else {
                  items.forEach(item => {
                        item.material.forEach(m => {
                           m.opacity = 1;
                      })
                  })
                  
                  var fromControlsTarget = {
                     x: controls.target.x,
                     y: controls.target.y,
                     z: controls.target.z
                  };

                  var toControlsTarget = {
                     x: 600,
                     y: -150,
                     z: 450
                  };
                  var fromCameraPosition = {
                     x: camera.position.x,
                     y: camera.position.y,
                     z: camera.position.z
                  };

                  var toCameraPosition = {
                     x: 600,
                     y: 10,
                     z: 2200
                  };
                  controls.reset();
                  var tweenControlsTarget = new TWEEN.Tween(fromControlsTarget)
                        .to(toControlsTarget, 1000)
                        .easing(TWEEN.Easing.Linear.None)
                        .onUpdate(function () {
                           controls.target.set(this._object.x, this._object.y, this._object.z);
                        })
                        .start()
                  var tweenCameraPosition = new TWEEN.Tween(fromCameraPosition)
                     .to(toCameraPosition, 1000)
                     .easing(TWEEN.Easing.Linear.None)
                     .onUpdate(function () {
                        camera.position.set(this._object.x, this._object.y, this._object.z);
                     })
                     .start()
               }
            }
         }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				controls.handleResize();
				render();
         }
         
			function animate() {
            render();
            requestAnimationFrame( animate );
            TWEEN.update();
				controls.update();			
         }
         
			function render() {
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>